import {
  ENVIRONMENT,
  EventType,
  IContext,
  IReaction,
  MODE_SSR,
  Overmind,
  OvermindMock,
} from 'overmind'
import * as react from 'react'
import {
  unstable_cancelCallback,
  unstable_getCurrentPriorityLevel,
  unstable_scheduleCallback,
} from 'scheduler'

const IS_PRODUCTION = ENVIRONMENT === 'production'
const IS_TEST = ENVIRONMENT === 'test'
const isNode =
  !IS_TEST && process && process.title && process.title.includes('node')

export type IReactComponent<P = any> =
  | react.StatelessComponent<P>
  | react.ComponentClass<P>
  | react.ClassicComponentClass<P>

// Diff / Omit taken from https://github.com/Microsoft/TypeScript/issues/12215#issuecomment-311923766
type Omit<T, K extends keyof T> = Pick<
  T,
  ({ [P in keyof T]: P } &
    { [P in K]: never } & { [x: string]: never; [x: number]: never })[keyof T]
>

function getFiberType(component) {
  if (component.type) {
    // React.memo
    return getFiberType(component.type)
  }
  // React.forwardRef
  return component.render || component
}

// Inspired from https://github.com/facebook/react/blob/master/packages/react-devtools-shared/src/backend/renderer.js
function getDisplayName(component): string {
  const type = getFiberType(component)
  return type.displayName || type.name || 'Anonymous'
}

function throwMissingContextError() {
  throw new Error(
    'The Overmind hook could not find an Overmind instance on the context of React. Please make sure you use the Provider component at the top of your application and expose the Overmind instance there. Please read more in the React guide on the website'
  )
}

const context = react.createContext<Overmind<any>>({} as Overmind<any>)
let nextComponentId = 0

export const Provider: react.ProviderExoticComponent<
  react.ProviderProps<Overmind<any> | OvermindMock<any>>
> = context.Provider

function useForceRerender() {
  const [{ flushId }, setTick] = react.useState({ tick: 0, flushId: 0 })

  const forceRerender = react.useCallback((flushId?) => {
    setTick((current) => ({
      ...current,
      tick: current.tick + 1,
      flushId: flushId || current.flushId,
    }))
  }, [])

  return {
    flushId,
    forceRerender,
  }
}

let currentComponentInstanceId = 0
const {
  ReactCurrentOwner,
} = (react as any).__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED
const useCurrentComponent = () => {
  return ReactCurrentOwner &&
    ReactCurrentOwner.current &&
    ReactCurrentOwner.current.elementType
    ? ReactCurrentOwner.current.elementType
    : {}
}

const useState = <Context extends IContext<any>>(
  cb?: (state: Context['state']) => any
): Context['state'] => {
  const overmind = react.useContext(context) as Overmind<any>

  if (!(overmind as any).mode) {
    throwMissingContextError()
  }

  if (isNode || (overmind as any).mode.mode === MODE_SSR) {
    return overmind.state
  }

  const trackingRef = react.useRef<any>(null)

  const { flushId, forceRerender } = useForceRerender()

  if (!trackingRef.current) {
    const tree = (overmind as any).proxyStateTreeInstance.getTrackStateTree()
    trackingRef.current = {
      tree,
      hasUpdatedBeforeCommit: false,
      stopTrackingTask: unstable_scheduleCallback(
        unstable_getCurrentPriorityLevel(),
        () => {
          trackingRef.current.tree.stopTracking()
        }
      ),
      state: cb ? cb(tree.state) : tree.state,
    }
  }

  if (IS_PRODUCTION) {
    react.useLayoutEffect(() => {
      trackingRef.current.mounted = true

      if (trackingRef.current.hasUpdatedBeforeCommit) {
        forceRerender()
      }

      return () => {
        ;(overmind as any).proxyStateTreeInstance.disposeTree(
          trackingRef.current.tree
        )
      }
    }, [])

    react.useLayoutEffect(() => {
      if (trackingRef.current.stopTrackingTask) {
        unstable_cancelCallback(trackingRef.current.stopTrackingTask)
        trackingRef.current.stopTrackingTask = null
      }
      trackingRef.current.tree.stopTracking()
    })
    trackingRef.current.tree.track(() => {
      if (trackingRef.current.mounted) {
        forceRerender()
      } else {
        trackingRef.current.hasUpdatedBeforeCommit = true
      }
    })
  } else {
    const component = useCurrentComponent()
    const name = getDisplayName(component)
    component.__componentId =
      typeof component.__componentId === 'undefined'
        ? nextComponentId++
        : component.__componentId

    const { current: componentInstanceId } = react.useRef<any>(
      currentComponentInstanceId++
    )

    react.useLayoutEffect(() => {
      trackingRef.current.mounted = true
      overmind.eventHub.emitAsync(EventType.COMPONENT_ADD, {
        componentId: component.__componentId,
        componentInstanceId,
        name,
        paths: Array.from(trackingRef.current.tree.pathDependencies) as any,
      })

      if (trackingRef.current.hasUpdatedBeforeCommit) {
        forceRerender()
      }

      return () => {
        ;(overmind as any).proxyStateTreeInstance.disposeTree(
          trackingRef.current.tree
        )
        overmind.eventHub.emitAsync(EventType.COMPONENT_REMOVE, {
          componentId: component.__componentId,
          componentInstanceId,
          name,
        })
      }
    }, [])

    react.useLayoutEffect(() => {
      if (trackingRef.current.stopTrackingTask) {
        unstable_cancelCallback(trackingRef.current.stopTrackingTask)
        trackingRef.current.stopTrackingTask = null
      }
      trackingRef.current.tree.stopTracking()
      overmind.eventHub.emitAsync(EventType.COMPONENT_UPDATE, {
        componentId: component.__componentId,
        componentInstanceId,
        name,
        flushId,
        paths: Array.from(trackingRef.current.tree.pathDependencies) as any,
      })
    })
    trackingRef.current.tree.track(() => {
      if (trackingRef.current.mounted) {
        forceRerender()
      } else {
        trackingRef.current.hasUpdatedBeforeCommit = true
      }
    })
  }

  return trackingRef.current.state
}

const useActions = <Context extends IContext<any>>(): Context['actions'] => {
  const overmind = react.useContext(context) as Overmind<any>

  if (!(overmind as any).mode) {
    throwMissingContextError()
  }

  return overmind.actions
}

const useEffects = <Context extends IContext<any>>(): Context['effects'] => {
  const overmind = react.useContext(context) as Overmind<any>

  if (!(overmind as any).mode) {
    throwMissingContextError()
  }

  return overmind.effects
}

const useReaction = <Context extends IContext<any>>(): IReaction<Context> => {
  const overmind = react.useContext(context) as Overmind<any>

  if (!(overmind as any).mode) {
    throwMissingContextError()
  }

  return overmind.reaction as any
}

export interface StateHook<Context extends IContext<any>> {
  (): Context['state']
  <T>(cb?: (state: Context['state']) => T): T
}

export const createStateHook: <Context extends IContext<any>>() => StateHook<
  Context
> = () => useState

export const createActionsHook: <
  Context extends IContext<any>
>() => () => Context['actions'] = () => {
  return useActions as any
}

export const createEffectsHook: <
  Context extends IContext<any>
>() => () => Context['effects'] = () => {
  return useEffects as any
}

export const createReactionHook: <
  Context extends IContext<any>
>() => () => IReaction<Context> = () => {
  return useReaction as any
}
