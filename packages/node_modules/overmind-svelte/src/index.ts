import { EventType, Overmind, IReaction, IConfiguration } from 'overmind'
import { ITrackCallback } from 'proxy-state-tree'
import { onMount, afterUpdate, onDestroy } from 'svelte'
import { Readable } from 'svelte/store'

const IS_PRODUCTION = process.env.NODE_ENV === 'production'

let nextComponentId = 0

export function createMixin<Config extends IConfiguration>(
  overmind: Overmind<Config>
) {
  const componentId = nextComponentId++
  let nextComponentInstanceId = 0
  let currentFlushId = 0

  // Svelte "store contract" https://svelte.dev/docs#Store_contract
  const subscribe: Readable<any>['subscribe'] = (listener) => {
    // @ts-ignore
    const tree = overmind.proxyStateTree.getTrackStateTree()
    const componentInstanceId = nextComponentInstanceId++
    let isUpdating = false

    const onUpdate: ITrackCallback = (_mutations, _paths, flushId) => {
      tree.track(onUpdate)
      currentFlushId = flushId
      isUpdating = true
      listener(tree.state)
    }

    tree.track(onUpdate)

    listener(tree.state)

    if (IS_PRODUCTION) {
      afterUpdate(() => {
        tree.stopTracking()
        isUpdating = false
      })
    } else {
      onMount(() => {
        overmind.eventHub.emitAsync(EventType.COMPONENT_ADD, {
          componentId,
          componentInstanceId,
          name: '',
          paths: Array.from(tree.pathDependencies),
        })
      })

      afterUpdate(() => {
        tree.stopTracking()
        if (isUpdating) {
          overmind.eventHub.emitAsync(EventType.COMPONENT_UPDATE, {
            componentId,
            componentInstanceId,
            name: '',
            flushId: currentFlushId,
            paths: Array.from(tree.pathDependencies),
          })
        }
        isUpdating = false
      })
    }

    return () => {
      // @ts-ignore
      overmind.proxyStateTree.disposeTree(tree)
      overmind.eventHub.emitAsync(EventType.COMPONENT_REMOVE, {
        componentId,
        componentInstanceId: componentInstanceId,
        name: '',
      })
    }
  }

  const reaction: IReaction<Config> = (...args) => {
    const dispose = overmind.reaction(...args)

    onDestroy(() => {
      dispose()
    })

    return dispose
  }

  return {
    state: { ...overmind.state, subscribe },
    actions: overmind.actions,
    effects: overmind.effects,
    addMutationListener: overmind.addMutationListener,
    reaction: reaction,
  }
}
