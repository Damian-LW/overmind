import { PATH, PROXY_TREE, VALUE } from 'proxy-state-tree'

import { deepCopy } from './utils'
import { IState } from '.'

type TStates = {
  [state: string]: IState | Statemachine<any, any>
}

export type Exact<Expected, Actual> =
  keyof Expected extends keyof Actual
    ? keyof Actual extends keyof Expected
      ? Expected extends ExactElements<Expected, Actual>
        ? Expected
        : never
      : never
    : never;

type ExactElements<Expected, Actual> = {
  [K in keyof Actual]: K extends keyof Expected
    ? Expected[K] extends Actual[K]
      ? Actual[K] extends Expected[K]
        ? Expected[K]
        : never
      : never
    : never
};

export type StatemachineTransitions<States extends TStates> = {
  [State in keyof States]: Array<keyof States>
}

export interface MachineMethods<States extends TStates> {
  matches<T extends keyof States>(state: T | T[]): boolean;
  transition<T extends keyof States>(
    state: T,
    newState: States[T]
  ): boolean;
}

export type Statemachine<States extends TStates, Base extends IState = never> = ([Base] extends [never] ? MachineMethods<States> : Base & MachineMethods<States>) & {
  [K in keyof States]: States[K]
} & {
  current: keyof States
}

const INITIAL_STATE = Symbol('INITIAL_STATE')
const TRANSITIONS = Symbol('TRANSITIONS')
const BASE = Symbol('BASE')
const STATE = Symbol('STATE')
const NO_PROP = Symbol('NO_PROP')
const IS_DISPOSED = Symbol('IS_DISPOSED')

export class StateMachine<Base extends IState, States extends TStates>  {
  current: keyof States
  private [INITIAL_STATE]: keyof States
  private [STATE]: any
  private [BASE]: any
  private [IS_DISPOSED] = false
  private clone() {
    return new StateMachine(this[TRANSITIONS], this[INITIAL_STATE] as string, deepCopy(this[STATE]), deepCopy(this[BASE]))
  }
  private dispose() {
    Object.keys(this[VALUE]).forEach((key) => {
      if (this[VALUE][key] instanceof StateMachine) {
        this[key].dispose()
      }
    })
    this[VALUE][IS_DISPOSED] = true
  }
  constructor(transitions: StatemachineTransitions<States>, initialState: string, state: States, base: Base) {
    this[STATE] = state
    this[INITIAL_STATE] = initialState
    this[TRANSITIONS] = transitions
    this[BASE] = base || {}
    this.current = initialState
    Object.assign(this, Object.keys(transitions).reduce<any>((aggr, key) => {
      aggr[key] = key === initialState ? state : null

      return aggr
    }, {}), base)
  }
  matches(states) {
    if (this[VALUE][IS_DISPOSED]) {
      if (process.env.NODE_ENV === 'development') {
        console.warn(`Overmind - The statemachine at "${this[PATH]}" has been disposed, but you tried to match on it`)
      }
      return
    }

    states = Array.isArray(states) ? states : [states]

    if (states.includes(this.current)) {
      const tree = (this[PROXY_TREE].master.mutationTree || this[PROXY_TREE])

      if (!tree.enableMutations) {   
        throw new Error('Overmind - The "matches" API is only to be used for state changes in actions, point to "state.current" to check current state of machine')
      }

      tree.enableMutations()
      
      Promise.resolve().then(() => tree.blockMutations())
      return true
    }

    return false
  }
  transition(state, newState) {
    if (this[VALUE][IS_DISPOSED]) {
      if (process.env.NODE_ENV === 'development') {
        console.warn(`Overmind - The statemachine at "${this[PATH]}" has been disposed, but you tried to transition on it`)
      }
      return
    }

    const transitions = this[VALUE][TRANSITIONS] 

    if (transitions[this.current].includes(state)) {
      const tree = (this[PROXY_TREE].master.mutationTree || this[PROXY_TREE])


      tree.enableMutations()

      if (this[this.current as any] instanceof StateMachine) {
        this[this.current as any].dispose()
      } else {
        Object.keys(this[this.current as any]).forEach((key) => {
          if (this[key] instanceof StateMachine) {
            this[key].dispose()
          }
        })
      }

      this[this.current as any] = null
      this.current = state
      this[this.current as any] = newState

      Promise.resolve().then(() => tree.blockMutations())

      return true
    } else if (process.env.NODE_ENV === 'development' && state !== this.current) {
      console.warn(`Overmind Statemachine - You tried to transition into "${state}", but it is not a valid transition. The valid transitions are ${JSON.stringify(transitions[this.current])}`)
    } else if (process.env.NODE_ENV === 'development' && state === this.current) {
      console.warn(`Overmind Statemachine - You tried to transition into "${state}", but you are already in this state. Do a "match" before running this piece of logic or add it as a valid state transition for this state`)
    }

    return false
  }
}

export type StatemachineFactory<States extends TStates, Base extends IState = never> = {
  create<T extends keyof States>(...args: [Base] extends [never] ? [T, Exact<States[T], {}> extends never ? States[T] : { [NO_PROP]?: true}] : [T, Exact<States[T], {}> extends never ? States[T] : { [NO_PROP]?: true}, Base]): Statemachine<States, Base> 
}

export function statemachine<States extends TStates, Base extends IState = never>(transitions: StatemachineTransitions<States>): StatemachineFactory<States, Base> {
   return {
     create(...args) {
      return new StateMachine(transitions, args[0] as string, args[1] as any, args[2] || {}) as any
     }
   }
}
