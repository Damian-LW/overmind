import { PATH, PROXY_TREE, VALUE } from 'proxy-state-tree'

import { deepCopy } from './utils'
import { IState } from '.'

type TStates = {
  current: string
} & {
  [key: string]: IState | Statemachine<any, any>
}

export type StatemachineTransitions<States extends TStates, BaseState extends IState> = {
  [State in States["current"]]: Array<States["current"]> | ((payload: Omit<States extends { current: State } ? States & Partial<BaseState> : never, 'current'>, state: Statemachine<States, BaseState>) =>  States["current"] | Array<States["current"]> | boolean)
}

export interface MachineMethods<States extends TStates, Base extends IState> {
  matches<T extends States["current"]>(
    state: T,
  ): Statemachine<States extends { current: T} ? States : never, Base> | undefined
  transition<T extends States["current"]>(
    newState: Partial<Base> & States extends { current: T } ? States : never
  ): Statemachine<States extends { current: T} ? States : never, Base> | undefined
  transition<T extends States["current"]>(
    newState: T,
    cb: (state: Statemachine<States extends { current: T} ? States : never, Base>) => void
  ): Statemachine<States extends { current: T} ? States : never, Base> | undefined
}

export type Statemachine<States extends TStates, Base extends IState = never> = ([Base] extends [never] ? MachineMethods<States, {}> : Base & MachineMethods<States, Base>) & States

const INITIAL_STATE = Symbol('INITIAL_STATE')
const TRANSITIONS = Symbol('TRANSITIONS')
const STATE = Symbol('STATE')
const IS_DISPOSED = Symbol('IS_DISPOSED')
const CURRENT_DYNAMIC_TRANSITION = Symbol('CURRENT_DYNAMIC_TRANSITION')

export class StateMachine<Base extends IState, States extends TStates>  {
  current: States["current"]
  private [INITIAL_STATE]: States["current"]
  private [TRANSITIONS]: StatemachineTransitions<States, Base>
  private [STATE]: any
  private [IS_DISPOSED] = false
  private [CURRENT_DYNAMIC_TRANSITION]: any
  private clone() {
    return new StateMachine(this[TRANSITIONS], deepCopy(this[STATE]))
  }
  private dispose() {
    Object.keys(this[VALUE]).forEach((key) => {
      if (this[VALUE][key] instanceof StateMachine) {
        this[key].dispose()
      }
    })
    this[VALUE][IS_DISPOSED] = true
  }
  constructor(transitions: StatemachineTransitions<States, Base>, state: States) {
    this[STATE] = state
    this[INITIAL_STATE] = state.current
    this[TRANSITIONS] = transitions
    Object.assign(this, state)
  }
  transition(...args) {
    if (this[VALUE][IS_DISPOSED]) {
      if (process.env.NODE_ENV === 'development') {
        console.warn(`Overmind - The statemachine at "${this[PATH]}" has been disposed, but you tried to transition on it`)
      }
      return
    }

    const transition = this[VALUE][CURRENT_DYNAMIC_TRANSITION] || this[VALUE][TRANSITIONS][this.current]

    const newState = args.length === 2 ? args[0] : args[0].current

    if (transition.includes(newState)) {
      let dynamicResult: any

      this[VALUE][CURRENT_DYNAMIC_TRANSITION] = null

      if (typeof this[VALUE][TRANSITIONS][newState] === 'function') {
        dynamicResult = this[VALUE][TRANSITIONS][newState](newState, this)

        if (!dynamicResult) {
          return
        }

        if (Array.isArray(dynamicResult)) {
          this[VALUE][CURRENT_DYNAMIC_TRANSITION] = dynamicResult
        }
      }

      const existingState = this.current
      if (args.length === 2) {
        this.current = newState
        args[1](this)
      } else {
        Object.assign(this, args[0])
      }
      

      if (typeof dynamicResult === 'string') {
        this[VALUE][CURRENT_DYNAMIC_TRANSITION] = [dynamicResult]
        return this.transition({ current: dynamicResult })
      }

      if (dynamicResult === true) {
        this[VALUE][CURRENT_DYNAMIC_TRANSITION] = [existingState]
        return this.transition({ current: existingState })
      }

      return this
    } else if (process.env.NODE_ENV === 'development' && newState !== this.current) {
      console.warn(`Overmind Statemachine - You tried to transition into "${newState.current}", but it is not a valid transition. The valid transitions are ${JSON.stringify(transition)}`)
    } else if (process.env.NODE_ENV === 'development' && newState === this.current) {
      console.warn(`Overmind Statemachine - You tried to transition into "${newState}", but you are already in this state. Do a "match" before running this piece of logic or add it as a valid state transition for this state`)
    }

    return
  }
  matches(state: any) {
    if (this.current === state) {
      return this
    }
  }
}

export type StatemachineFactory<States extends TStates, Base extends IState = never> = {
  create(state: [Base] extends [never] ? States : States & Base): Statemachine<States, Base> 
}

export function statemachine<States extends TStates, Base extends IState = never>(transitions: StatemachineTransitions<States, Base>): StatemachineFactory<States, Base> {
   return {
     create(state) {
      return new StateMachine(transitions, state as any) as any
     }
   }
}
