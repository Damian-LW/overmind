import { PROXY_TREE, VALUE, PATH } from 'proxy-state-tree'

import { deepCopy } from './utils'
import { IState } from '.'

type TStates = {
  current: string | number,
}

export type Exact<Expected, Actual> =
  keyof Expected extends keyof Actual
    ? keyof Actual extends keyof Expected
      ? Expected extends ExactElements<Expected, Actual>
        ? Expected
        : never
      : never
    : never;

type ExactElements<Expected, Actual> = {
  [K in keyof Actual]: K extends keyof Expected
    ? Expected[K] extends Actual[K]
      ? Actual[K] extends Expected[K]
        ? Expected[K]
        : never
      : never
    : never
};

export type StatemachineTransitions<States extends TStates> = {
  [State in States["current"]]: Array<States["current"]>
}

export interface MachineMethods<States extends TStates, Base extends IState = {}> {
  matches<T extends States["current"], O = void>(state: T | T[], cb: (current: Statemachine<Base, States, States extends {
    current: T
  } ? States : never>) => O): O;
  transition<T extends States["current"], O = void>(
    state: T,
    newState: States extends {
      current: T  
    } ? Exact<Omit<States, 'current'>, {}> extends never ?  Omit<States, 'current'> & Partial<Base> : Exact<Partial<Base>, {}> extends never ? Partial<Base> : { [NO_PROP]?: true} : never,
    effectsCallback?: ((current: Statemachine<Base, States, States extends {
      current: T
    } ? States : never>) => O)
  ): O;
}

export type Statemachine<Base extends IState, States extends TStates, State extends TStates = States> = Base extends never ? State & MachineMethods<States> : Base & State & MachineMethods<States, Base>

const INITIAL_STATE = Symbol('INITIAL_STATE')
const TRANSITIONS = Symbol('TRANSITIONS')
const BASE = Symbol('BASE')
const STATE = Symbol('STATE')
const CURRENT_KEYS = Symbol('CURRENT_KEYS')
const NO_PROP = Symbol('NO_PROP')
const IS_DISPOSED = Symbol('IS_DISPOSED')

export class StateMachine<Base extends IState, States extends TStates, State extends TStates = States, >  {
  current: State["current"]
  private [INITIAL_STATE]: State["current"]
  private [STATE]: any
  private [BASE]: any
  private [IS_DISPOSED] = false
  private clone() {
    return new StateMachine(this[TRANSITIONS], deepCopy(this[STATE]), deepCopy(this[BASE]))
  }
  private dispose() {
    this
  }
  constructor(transitions: StatemachineTransitions<States>, state: States, base: Base) {
    this[STATE] = state
    this[INITIAL_STATE] = state.current
    this[TRANSITIONS] = transitions
    this[BASE] = base || {} 
    this[CURRENT_KEYS] = Object.keys(state)
    Object.assign(this, state, base)
  }
  matches(states, cb) {
    if (this[VALUE][IS_DISPOSED]) {
      if (process.env.NODE_ENV === 'development') {
        console.warn(`Overmind - The statemachine at "${this[PATH]}" has been disposed, but you tried to match on it`)
      }
      return
    }

    states = Array.isArray(states) ? states : [states]

    if (states.includes(this.current)) {
      const tree = (this[PROXY_TREE].master.mutationTree || this[PROXY_TREE])

      if (!tree.enableMutations) {   
        throw new Error('Overmind - The "matches" API is only to be used for state changes in actions, point to "state.current" to check current state of machine')
      }

      tree.enableMutations()
      const result = cb(this)
      tree.blockMutations()
      return result
    }
  }
  transition(state, newState, effectsCallback) {
    if (this[VALUE][IS_DISPOSED]) {
      if (process.env.NODE_ENV === 'development') {
        console.warn(`Overmind - The statemachine at "${this[PATH]}" has been disposed, but you tried to transition on it`)
      }
      return
    }

    const transitions = this[VALUE][TRANSITIONS] 

    if (transitions[this.current].includes(state)) {
      const tree = (this[PROXY_TREE].master.mutationTree || this[PROXY_TREE])
      const baseKeys = Object.keys(this[VALUE][BASE])

      tree.enableMutations()

      this[VALUE][CURRENT_KEYS].forEach((key) => {
        if (!baseKeys.includes(key)) {
          if (this[key] instanceof StateMachine) {
            this[key].dispose()
          }
          delete this[key]
        }
      })

      Object.assign(this, newState)
      this.current = state
      this[VALUE][CURRENT_KEYS] = Object.keys(newState)

      tree.blockMutations()

      let result
      if (effectsCallback) {
        result = effectsCallback(this)
      }

      return result
    } else if (process.env.NODE_ENV === 'development' && state !== this.current) {
      console.warn(`Overmind Statemachine - You tried to transition into "${state}", but it is not a valid transition. The valid transitions are ${JSON.stringify(transitions[this.current])}`)
    } else if (process.env.NODE_ENV === 'development' && state === this.current) {
      console.warn(`Overmind Statemachine - You tried to transition into "${state}", but you are already in this state. Do a "match" before running this piece of logic or add it as a valid state transition for this state`)
    }
  }
}

export function statemachine<States extends TStates, Base extends IState = never>(...args: [Base] extends [never] ? [StatemachineTransitions<States>, States] : [StatemachineTransitions<States>, States, Base]): Statemachine<[Base] extends [never] ? {} : Base, States> {
  return new StateMachine(args[0], args[1], args[2] || {}) as any
}
