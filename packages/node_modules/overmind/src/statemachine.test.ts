import { IAction, createOvermind, createOvermindMock } from './'
import { statemachine } from './statemachine'

describe('Statemachine', () => {
  
  test('should set initial state', () => {

    type States = {
      current: 'FOO'
    } | {
      current: 'BAR'
    }

    const state = statemachine<States>({
      FOO: ['BAR'],
      BAR: ['FOO']
    }).create({
      current: 'FOO'
    })

    
    const config = {
      state,
    } 

    const overmind = createOvermindMock(config)

    expect(overmind.state.current).toBe('FOO')
  })


  test('should transition state', () => {
    type States = {
     current: 'FOO'
    } | {
      current: 'BAR'
    }

    type Events = {
      type: 'TOGGLE',
    }

    const state = statemachine<States, Events>({
      TOGGLE: (state) => state.current === 'FOO' ? 'BAR' : 'FOO'
    }).create({
      current: 'FOO'
    })
    const transition: Action = ({ state }) => {
      state.transition('TOGGLE')
    }

    const config = {
      state,
      actions: {
        transition
      }
    } 

    interface Action extends IAction<typeof config, void, void> {}

    const overmind = createOvermindMock(config)
    

    overmind.actions.transition()
    expect(overmind.state.current).toBe('BAR')
  })

  
  test('should ignore transition when no state returned', () => {

    type States = {
      current: 'FOO'
    } | {
      current: 'BAR'
    }

    type Events = {
      type: 'TOGGLE',
    }

    const state = statemachine<States, Events>({
      TOGGLE: () => {}
    }).create({
      current: 'FOO'
    })
    const transition: Action = ({ state }) => {
      state.transition('TOGGLE')
    }

    const config = {
      state,
      actions: {
        transition
      }
    } 

    interface Action extends IAction<typeof config, void, void> {}

    const overmind = createOvermindMock(config)
    overmind.actions.transition()
    expect(overmind.state.current).toBe('FOO')
  })



  test('should flush changes to transitions', () => {
    expect.assertions(1)

    type States = {
      current: 'FOO'
    } | {
      current: 'BAR'
    }

    type Events = {
      type: 'TOGGLE',
    }

    const state = statemachine<States, Events>({
      TOGGLE: () => 'BAR'
    }).create({
      current: 'FOO'
    })
    
    const transition: Action = ({ state }) => {
      state.transition('TOGGLE')
    }

    const config = {
      state,
      actions: {
        transition
      }
    } 

    interface Action extends IAction<typeof config, void, void> {}

    const overmind = createOvermind(config)
    overmind.reaction((state) => state.current, (value) => {
      expect(value).toEqual('BAR')
    })
    overmind.actions.transition()
  })

  test('should make copy of statemachine during tests', () => {
    type States = {
      current: 'FOO'
      obj: {
        foo: string
      }
    } | {
      current: 'BAR',
      obj: {
        foo: string
      }
    }

    const state = statemachine<States>({
      FOO: ['BAR'],
      BAR: ['FOO']
    }).create({
      current: 'FOO',
      obj: {
        foo: 'bar'
      }
    })
    
    const config = {
      state,
      actions: {
        changeFoo({ state }) {
          state.obj.foo = 'bar2'
        }
      }
    } 

    const overmind = createOvermindMock(config)

    // @ts-ignore
    overmind.actions.changeFoo()

    expect(overmind.state.obj.foo).toBe('bar2')


    const overmind2 = createOvermindMock(config)

    expect(overmind2.state.obj.foo).toBe('bar')
  })
})
