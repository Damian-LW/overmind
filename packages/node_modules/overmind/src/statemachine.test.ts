import { PROXY_TREE } from 'proxy-state-tree'

import { IAction, createOvermind, createOvermindMock } from './'
import { Statemachine, statemachine } from './statemachine'

describe('Statemachine', () => {
  
  test('should set initial state', () => {

    type States =  {
      current: 'FOO'
    } | {
      current: 'BAR'
    }

    const state = statemachine<States>({
      FOO: ['BAR'],
      BAR: ['FOO']
    }, {
      current: 'FOO',
    })
    
    const config = {
      state,
    } 

    const overmind = createOvermindMock(config)

    expect(overmind.state.current).toBe('FOO')
  })

  test('should transition state', () => {
    type States = {
      current: 'FOO'
    } | {
      current: 'BAR'
    }

    const state = statemachine<States>({
      FOO: ['BAR'],
      BAR: ['FOO']
    }, {
      current: 'FOO',
    })
    const transition: Action = ({ state }) => {
      state.transition('BAR', {})
    }

    const config = {
      state,
      actions: {
        transition
      }
    } 

    interface Action extends IAction<typeof config, void, void> {}

    const overmind = createOvermindMock(config)
    

    overmind.actions.transition()
    expect(overmind.state.current).toBe('BAR')
  })

  test('should ignore transition to invalid state', () => {

    type States = {
      current: 'FOO'
    } | {
      current: 'BAR'
    }

    const state = statemachine<States>({
      FOO: [],
      BAR: ['FOO']
    }, {
      current: 'FOO'
    })
    const transition: Action = ({ state }) => {
      state.transition('BAR', {})
    }

    const config = {
      state,
      actions: {
        transition
      }
    } 

    interface Action extends IAction<typeof config, void, void> {}

    const overmind = createOvermindMock(config)
    overmind.actions.transition()
    expect(overmind.state.current).toBe('FOO')
  })

  test('should run entry and exit transition', async () => {
    expect.assertions(3)
    type States = {
      current: 'FOO'
    } | {
      current: 'BAR'
    }

    const state = statemachine<States>({
        FOO: ['BAR'],
        BAR: ['FOO']
      }, {
        current: 'FOO'
      })
    
    const transition: Action = async ({ state }) => {
      state.transition('BAR', {}, (barState) => {
        expect(barState.current).toBe('BAR')
        state.transition('FOO', {}, (fooState) => {
          expect(fooState.current).toBe('FOO')
        })
      })
    }

    const config = {
      state,
      actions: {
        transition
      }
    } 

    interface Action extends IAction<typeof config, void, void | Promise<void>> {}

    const overmind = createOvermindMock(config)
      
    await overmind.actions.transition()
    expect(overmind.state.current).toBe('FOO')
  })
   
  test('should flush changes to transitions', () => {
    expect.assertions(1)

    type States = {
      current: 'FOO'
    } | {
      current: 'BAR'
    }

    const state = statemachine<States>({
      FOO: ['BAR'],
      BAR: ['FOO']
      }, {
        current: 'FOO'
      })
    
    const transition: Action = ({ state }) => {
      state.transition('BAR', {})
    }

    const config = {
      state,
      actions: {
        transition
      }
    } 

    interface Action extends IAction<typeof config, void, void> {}

    const overmind = createOvermind(config)
    overmind.reaction((state) => state.current, (value) => {
      expect(value).toBe('BAR')
    })
    overmind.actions.transition()
  })

  test('should error when mutating async in transitions', async () => {
    expect.assertions(1)

    type States = {
      current: 'FOO'
    } | {
      current: 'BAR'
    }

    const state = statemachine<States>({
        FOO: ['BAR'],
        BAR: ['FOO']
      }, {
        current: 'FOO'
      })
    const transition: Action = async ({ state }) => {
      await state.transition('BAR', {}, async () => {
        await Promise.resolve()
        expect(state[PROXY_TREE].master.mutationTree.isBlocking).toBe(true)
      })
    }

    const config = {
      state,
      actions: {
        transition
      }
    } 

    interface Action extends IAction<typeof config, void, Promise<void>> {}

    const overmind = createOvermind(config)

    return overmind.actions.transition()
  })

  test('should enable mutations after new async matching or transition', async () => {
    expect.assertions(3)

    type States = {
      current: 'FOO'
    } | {
      current: 'BAR'
    }

    const state = statemachine<States>({
        FOO: ['BAR'],
        BAR: ['FOO']
      }, {
        current: 'FOO',
      })
    const transition: Action = async ({ state }) => {
      await state.transition('BAR', {}, async () => {
        await Promise.resolve()
        expect(state[PROXY_TREE].master.mutationTree.isBlocking).toBe(true)
        if (state.matches('BAR')) {
          expect(state[PROXY_TREE].master.mutationTree.isBlocking).toBe(false)
          await Promise.resolve()
          state.transition('FOO', {}, () => {
            expect(state[PROXY_TREE].master.mutationTree.isBlocking).toBe(false)
          })
        }
      })
    }
    

    const config = {
      state,
      actions: {
        transition
      }
    } 

    interface Action extends IAction<typeof config, void, Promise<void>> {}

    const overmind = createOvermind(config)

    return overmind.actions.transition()
  })
          
  test('should make copy of statemachine during tests', () => {

    type States = {
      current: 'FOO'
      obj: {
        foo: string
      }
    } | {
      current: 'BAR'
      obj: {
        foo: string
      }
    }

    const state = statemachine<States>({
      FOO: ['BAR'],
      BAR: ['FOO']
    }, {
      current: 'FOO',
      obj: {
        foo: 'bar'
      }
    })
    const config = {
      state,
      actions: {
        changeFoo({ state }) {
          state.obj.foo = 'bar2'
        }
      }
    } 

    const overmind = createOvermindMock(config)

    // @ts-ignore
    overmind.actions.changeFoo()
    expect(overmind.state.obj.foo).toBe('bar2')


    const overmind2 = createOvermindMock(config)

    expect(overmind2.state.obj.foo).toBe('bar')
  })
  test('should have base state', () => {

    type States = {
      current: 'FOO'
    } | {
      current: 'BAR'
    }

    type Base = {
      obj: {
        foo: string
      }
    }

    const state = statemachine<States, Base>({
      FOO: ['BAR'],
      BAR: ['FOO']
    }, {
      current: 'FOO',
    }, {
      obj: {
        foo: 'bar'
      }
    })

    const config = {
      state,
      actions: {
        changeFoo({ state }) {
          state.obj.foo = 'bar2'
        }
      }
    } 

    const overmind = createOvermindMock(config)

    // @ts-ignore
    overmind.actions.changeFoo()
    expect(overmind.state.obj.foo).toBe('bar2')


    const overmind2 = createOvermindMock(config)

    expect(overmind2.state.obj.foo).toBe('bar')
  })
  test('should delete existing state and merge in new state, keep base', () => {

    type States = {
      current: 'FOO'
      foo: string
    } | {
      current: 'BAR'
      bar: number
    }

    type Base = {
      baz: boolean
    }

    const state = statemachine<States, Base>({
      FOO: ['BAR'],
      BAR: ['FOO']
    }, {
      current: 'FOO',
      foo: 'bar'
    }, {
      baz: true
    })
 
    const transition: Action = async ({ state }) => {
      await state.transition('BAR', {
        bar: 123,
      }, async (barState) => {
        expect(barState.bar).toBe(123)
        await Promise.resolve()
        await state.transition('FOO', {
          foo: '123'
        }, async (fooState) => {
          expect(fooState.foo).toBe('123')
          await Promise.resolve()
        })
      })

    }

    const config = {
      state,
      actions: {
        transition
      }
    } 

    interface Action extends IAction<typeof config, void, Promise<void>> {}

    const overmind = createOvermindMock(config)

    overmind.actions.transition()
  })
})
