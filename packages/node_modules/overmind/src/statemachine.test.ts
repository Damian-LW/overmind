import { PROXY_TREE } from 'proxy-state-tree'

import { IAction, createOvermind, createOvermindMock } from './'
import { Statemachine, statemachine } from './statemachine'

describe('Statemachine', () => {
  
  test('should set initial state', () => {

    type States =  {
      current: 'FOO'
    } | {
      current: 'BAR'
    }

    const state = statemachine<States>({
      FOO: ['BAR'],
      BAR: ['FOO']
    }).create({
      current: 'FOO'
    })

    
    const config = {
      state,
    } 

    const overmind = createOvermindMock(config)

    expect(overmind.state.current).toBe('FOO')
  })


  
  test('should transition state', () => {
    type States = {
     current: 'FOO'
    } | {
      current: 'BAR'
    }

    const state = statemachine<States>({
      FOO: ['BAR'],
      BAR: ['FOO']
    }).create({
      current: 'FOO'
    })
    const transition: Action = ({ state }) => {
      state.transition({
        current: 'BAR'
      })
    }

    const config = {
      state,
      actions: {
        transition
      }
    } 

    interface Action extends IAction<typeof config, void, void> {}

    const overmind = createOvermindMock(config)
    

    overmind.actions.transition()
    expect(overmind.state.current).toBe('BAR')
  })

  test('should ignore transition to invalid state', () => {

    type States = {
      current: 'FOO'
    } | {
      current: 'BAR'
    }

    const state = statemachine<States>({
      FOO: [],
      BAR: ['FOO']
    }).create({
      current: 'FOO'
    })
    const transition: Action = ({ state }) => {
      state.transition({
        current: 'BAR'
      })
    }

    const config = {
      state,
      actions: {
        transition
      }
    } 

    interface Action extends IAction<typeof config, void, void> {}

    const overmind = createOvermindMock(config)
    overmind.actions.transition()
    expect(overmind.state.current).toBe('FOO')
  })
  
  test('should allow dynamic transitions to prevent transition', () => {
    type States = {
     current: 'FOO'
    } | {
      current: 'BAR'
    } 

    const state = statemachine<States>({
      FOO: ['BAR'],
      BAR: () => false
    }).create({
      current: 'FOO'
    })
    const transition: Action = ({ state }) => {
      state.transition({
        current: 'BAR'
      })
    }

    const config = {
      state,
      actions: {
        transition
      }
    } 

    interface Action extends IAction<typeof config, void, void> {}

    const overmind = createOvermindMock(config)
    

    overmind.actions.transition()
    expect(overmind.state.current).toBe('FOO')
  })

  test('should allow dynamic transitions', () => {
    type States = {
     current: 'FOO'
    } | {
      current: 'BAR'
    } 

    const state = statemachine<States>({
      FOO: ['BAR'],
      BAR: () => ['FOO']
    }).create({
      current: 'FOO'
    })
    const transition: Action = ({ state }) => {
      state.transition({
        current: 'BAR'
      })
      expect(overmind.state.current).toBe('BAR')
      state.transition({
        current: 'FOO'
      })
    }

    const config = {
      state,
      actions: {
        transition
      }
    } 

    interface Action extends IAction<typeof config, void, void> {}

    const overmind = createOvermindMock(config)
    

    overmind.actions.transition()
    expect(overmind.state.current).toBe('FOO')
  })

  test('should allow transition from dynamic transition', () => {
    type States = {
     current: 'FOO'
    } | {
      current: 'BAR'
    } 

    const state = statemachine<States>({
      FOO: ['BAR'],
      BAR: () => ({ current: 'FOO' })
    }).create({
      current: 'FOO'
    })
    const transition: Action = ({ state }) => {
      state.transition({
        current: 'BAR'
      })
    }

    const config = {
      state,
      actions: {
        transition
      }
    } 

    interface Action extends IAction<typeof config, void, void> {}

    const overmind = createOvermindMock(config)
    

    overmind.actions.transition()
    expect(overmind.state.current).toBe('FOO')
  })

  test('should allow back transition', () => {
    type States = {
     current: 'FOO'
    } | {
      current: 'BAR'
    } 

    const state = statemachine<States>({
      FOO: ['BAR'],
      BAR: () => true
    }).create({
      current: 'FOO'
    })
    const transition: Action = ({ state }) => {
      state.transition({
        current: 'BAR'
      })
    }

    const config = {
      state,
      actions: {
        transition
      }
    } 

    interface Action extends IAction<typeof config, void, void> {}

    const overmind = createOvermindMock(config)
    

    overmind.actions.transition()
    expect(overmind.state.current).toBe('FOO')
  })

  test('should allow using callback for transition', () => {
    type States = {
      current: 'FOO'
    } | {
      current: 'BAR'
      bar: string
    } 

    const state = statemachine<States>({
      FOO: ['BAR'],
      BAR: []
    }).create({
      current: 'FOO'
    })
    const transition: Action = ({ state }) => {
      state.transition('BAR', (state) => {
        state.bar = 'bar2'
      })
    }

    const config = {
      state,
      actions: {
        transition
      }
    } 

    interface Action extends IAction<typeof config, void, void> {}

    const overmind = createOvermindMock(config)
    

    overmind.actions.transition()
    expect(overmind.state.current).toBe('BAR')
    expect(overmind.state.matches('BAR')?.bar).toBe('bar2')
  })

  test('should flush changes to transitions', () => {
    expect.assertions(1)

    type States = {
      current: 'FOO'
    } | {
      current: 'BAR'
    }

    const state = statemachine<States>({
      FOO: ['BAR'],
      BAR: ['FOO']
    }).create({
      current: 'FOO'
    })
    
    const transition: Action = ({ state }) => {
      state.transition({
        current: 'BAR'
      })
    }

    const config = {
      state,
      actions: {
        transition
      }
    } 

    interface Action extends IAction<typeof config, void, void> {}

    const overmind = createOvermind(config)
    overmind.reaction((state) => state.current, (value) => {
      expect(value).toEqual('BAR')
    })
    overmind.actions.transition()
  })

  test('should make copy of statemachine during tests', () => {
    type States = {
      current: 'FOO'
      obj: {
        foo: string
      }
    } | {
      current: 'BAR',
      obj: {
        foo: string
      }
    }

    const state = statemachine<States>({
      FOO: ['BAR'],
      BAR: ['FOO']
    }).create({
      current: 'FOO',
      obj: {
        foo: 'bar'
      }
    })
    
    const config = {
      state,
      actions: {
        changeFoo({ state }) {
          state.obj.foo = 'bar2'
        }
      }
    } 

    const overmind = createOvermindMock(config)

    // @ts-ignore
    overmind.actions.changeFoo()

    expect(overmind.state.obj.foo).toBe('bar2')


    const overmind2 = createOvermindMock(config)

    expect(overmind2.state.obj.foo).toBe('bar')
  })
})
