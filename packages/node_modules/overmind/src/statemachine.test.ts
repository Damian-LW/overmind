import { PROXY_TREE } from 'proxy-state-tree'

import { IAction, createOvermind, createOvermindMock } from './'
import { Statemachine, statemachine } from './statemachine'

describe('Statemachine', () => {
  
  test('should set initial state', () => {

    type States =  {
      FOO: {},
      BAR: {}
    }

    const state = statemachine<States>({
      FOO: ['BAR'],
      BAR: ['FOO']
    }).create('FOO', {})
    
    const config = {
      state,
    } 

    const overmind = createOvermindMock(config)

    expect(overmind.state.FOO).toBeDefined()
    expect(overmind.state.BAR).toBe(null)
  })

  
  test('should transition state', () => {
    type States = {
     FOO: {},
     BAR: {}
    }

    const state = statemachine<States>({
      FOO: ['BAR'],
      BAR: ['FOO']
    }).create('FOO', {})
    const transition: Action = ({ state }) => {
      state.transition('BAR', {})
    }

    const config = {
      state,
      actions: {
        transition
      }
    } 

    interface Action extends IAction<typeof config, void, void> {}

    const overmind = createOvermindMock(config)
    

    overmind.actions.transition()
    expect(overmind.state.BAR).toBeDefined()
  })

  test('should ignore transition to invalid state', () => {

    type States = {
      FOO: {},
      BAR: {}
    }

    const state = statemachine<States>({
      FOO: [],
      BAR: ['FOO']
    }).create('FOO', {})
    const transition: Action = ({ state }) => {
      state.transition('BAR', {})
    }

    const config = {
      state,
      actions: {
        transition
      }
    } 

    interface Action extends IAction<typeof config, void, void> {}

    const overmind = createOvermindMock(config)
    overmind.actions.transition()
    expect(overmind.state.FOO).toBeDefined()
  })

  test('should run entry and exit transition', async () => {
    expect.assertions(3)
    type States = {
      FOO: {},
      BAR: {}
    }

    const state = statemachine<States>({
        FOO: ['BAR'],
        BAR: ['FOO']
      }).create('FOO', {})
    
    const transition: Action = async ({ state }) => {
      if (state.transition('BAR', {})) {
        expect(state.BAR).toBeDefined()
        if (state.transition('FOO', {})) {
          expect(state.FOO).toBeDefined()
        }
      }
    }

    const config = {
      state,
      actions: {
        transition
      }
    } 

    interface Action extends IAction<typeof config, void, void | Promise<void>> {}

    const overmind = createOvermindMock(config)
      
    await overmind.actions.transition()
    expect(overmind.state.FOO).toBeDefined()
  })

  test('should flush changes to transitions', () => {
    expect.assertions(1)

    type States = {
      FOO: {},
      BAR: {}
,    }

    const state = statemachine<States>({
      FOO: ['BAR'],
      BAR: ['FOO']
    }).create('FOO', {})
    
    const transition: Action = ({ state }) => {
      state.transition('BAR', {})
    }

    const config = {
      state,
      actions: {
        transition
      }
    } 

    interface Action extends IAction<typeof config, void, void> {}

    const overmind = createOvermind(config)
    overmind.reaction((state) => state.BAR, (value) => {
      expect(value).toEqual({})
    })
    overmind.actions.transition()
  })
 
  test('should make copy of statemachine during tests', () => {

    type States = {
      FOO: {
        obj: {
          foo: string
        }
      }
      BAR: {
        obj: {
          foo: string
        }
      }
    }

    const state = statemachine<States>({
      FOO: ['BAR'],
      BAR: ['FOO']
    }).create('FOO', {
      obj: {
        foo: 'bar'
      }
    })
    
    const config = {
      state,
      actions: {
        changeFoo({ state }) {
          state.FOO.obj.foo = 'bar2'
        }
      }
    } 

    const overmind = createOvermindMock(config)

    // @ts-ignore
    overmind.actions.changeFoo()

    expect(overmind.state.FOO?.obj.foo).toBe('bar2')


    const overmind2 = createOvermindMock(config)

    expect(overmind2.state.FOO?.obj.foo).toBe('bar')
  })
    
  test('should have base state', () => {

    type States = {
      FOO: {}
      BAR: {}
    }

    type Base = {
      obj: {
        foo: string
      }
    }

    const state = statemachine<States, Base>({
      FOO: ['BAR'],
      BAR: ['FOO']
    }).create('FOO', {}, {
      obj: {
        foo: 'bar'
      }
    })

    const config = {
      state,
      actions: {
        changeFoo({ state }) {
          state.obj.foo = 'bar2'
        }
      }
    } 

    const overmind = createOvermindMock(config)

    // @ts-ignore
    overmind.actions.changeFoo()
    expect(overmind.state.obj.foo).toBe('bar2')


    const overmind2 = createOvermindMock(config)

    expect(overmind2.state.obj.foo).toBe('bar')
  })

  test('should delete existing state and merge in new state, keep base', () => {
    expect.assertions(3)
    type States = {
      FOO: {
        foo: string
      },
      BAR: {
        bar: number
      }
    }

    type Base = {
      baz: boolean
    }

    const state = statemachine<States, Base>({
      FOO: ['BAR'],
      BAR: ['FOO']
    }).create('FOO', {
      foo: 'bar'
    }, {
      baz: true
    })
 
    const transition: Action = async ({ state }) => {
      if (state.transition('BAR', {
        bar: 123
      })) {
        expect(state.BAR?.bar).toBe(123)
        await Promise.resolve()
        if (state.transition('FOO', { foo: '123'})) {
          expect(state.BAR).toBe(null)
          expect(state.FOO?.foo).toBe('123')
          await Promise.resolve()
        }
      }
    }

    const config = {
      state,
      actions: {
        transition
      }
    } 

    interface Action extends IAction<typeof config, void, Promise<void>> {}

    const overmind = createOvermindMock(config)

    overmind.actions.transition()
  })
         
  test('should dispose nested and base machines', async () => {
    expect.assertions(3)

    type BaseStates = {
      FOO: {},
      BAR: {}
    }

    const base = statemachine<BaseStates>({
      FOO: ['BAR'],
      BAR: ['FOO']
    })

    type States = {
      FOO: {},
      BAR: {}
    }


    const nested = statemachine<States, { base: Statemachine<BaseStates> }>({
      FOO: ['BAR'],
      BAR: ['FOO']
    })

    type ParentStates = {
      FOO: Statemachine<States, { base: Statemachine<BaseStates>}>
      BAR: {}
    }

    const state = statemachine<ParentStates>({
      FOO: ['BAR'],
      BAR: ['FOO']
    })

    const transition: Action = ({ state }) => {
      if (state.FOO) {
        const ref = state.FOO
        if (state.transition('BAR', {})) {
          expect(state.FOO).toBe(null)
          ref.transition('BAR', {})
          ref.base.transition('BAR', {})
          
          expect(ref.FOO).toBeDefined()
          expect(ref.base.FOO).toBeDefined()
        }
      }
    }

    const config = {
      state: state.create('FOO', nested.create('FOO', {}, {
        base: base.create('FOO', {})
      })),
      actions: {
        transition
      }
    } 

    interface Action extends IAction<typeof config, void, void> {}

    const overmind = createOvermindMock(config)
    // @ts-ignore
    overmind.isStrict = true
    
    overmind.actions.transition()
  })
  
})
